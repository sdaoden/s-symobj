S-SymObj
========

Copyright (c) 2010 - 2011 Steffen Daode Nurpmeso <sdaoden@gmail.com>.
All rights reserved.
See the file SymObj.pm for license information.
Have fun.

SymObj.pm provides an easy way to create and construct symbol-tables and
objects.  With a simple hash one defines class-fields an object should
have.  A generic constructor will then create the object and all of its
superclasses, checking and filtering arguments along the way, which
makes it pretty useful in times when the interface is unstable.  The
generated accessor subs which are created for arrays and hashes
implement a *feed in and forget* approach, since they can handle all
kinds of arguments (or try it); this is also true for the constructor.

SymObj.pm works for Multiple-Inheritance as good as perl(1) allows.
(That is to say that only one straight object tree can used,
further trees of @ISA need to be joined in, say.)
It should integrate neatlessly into SMP in respect to objects;
package "static-data" however is not protected.

S-SymObj is located at https://sourceforge.net/projects/ssymobj;
it is developed using a git(1) repository, which is located at
git.code.sf.net/p/ssymobj/code.


Installation
------------

SymObj.pm is a Perl module.  It should be in @INC.
To start off, simply place it in the directory in which the perl(1)
script which shall use it resides.


Usage
-----

Please use the pod2XY family of programs for the complete and
up-to-date documentation on SymObj.pm, e.g.

    pod2text SymObj.pm

The example from the documentation as of 2011-10-21:

    BEGIN { require 'SymObj.pm'; }

    {package X_Super;
        my %Fields;
        BEGIN {
            %Fields = (_name => '', _array => [], _hash => {} );
            SymObj::sym_create(__PACKAGE__, \%Fields);
        }

        sub new { SymObj::obj_ctor(__PACKAGE__, shift, \%Fields, \@_); }
    }

    {package SomePack;
        our (@ISA);
        BEGIN {
            @ISA = ('X_Super');
            SymObj::sym_create(__PACKAGE__, {}); # <- adds no fields on its own
        }

        sub new { SymObj::obj_ctor(__PACKAGE__, shift, {}, \@_); } # <- ..
    }

    my $sp = SomePack->new(name => 'SymObj is easy', 'unknown' => 'arg');

    # Other possible ctor arguments to init ->array() and ->hash()
    # array => '1' # (Need to push the rest later on)
    # array => ['1', '2', '3', '4']
    # array => [qw(1 2 3 4)]
    # array => {1 => '2', 3 => '4'}
    # hash => [qw(i you we all)]
    # hash => {i => 'you', we => 'all'}

    # The accessor subs also try to swallow everything.
    # They return references, except for scalars (always) and in wantarray
    # context, in which case you get a copy
    my $v = $sp->name('SymObj is really nice to use');
    print "name is <$v>\n";

    my $vr;
    $vr = $sp->array(   '1_1'); $sp->array('2_1');
    $vr = $sp->array(qw( 1_2                2_2));
    $vr = $sp->array([qw(1_3                2_3)]);
    $vr = $sp->array(   '1_4' =>           '2_4');
    my @arrcopy = $sp->array(); # wantarray context gives copy instead

    $vr = $sp->hash(    i_1 => 'you',  we_1 => 'all');
    $vr = $sp->hash(   'i_2',  'you', 'we_2',  'all');
    $vr = $sp->hash(qw( i_3     you    we_3     all));
    $vr = $sp->hash([qw(i_4     you    we_4     all)]);
    $vr = $sp->hash({   i_5 => 'you',  we_5 => 'all'});
    my %hashcopy = $sp->hash(); # wantarray context gives copy instead

    SymObj::obj_dump($sp);
