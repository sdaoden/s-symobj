S-SymObj
========

:Author:    Steffen "Daode" Nurpmeso
:Contact:   sdaoden@users.sf.net
:Date:      2010 - 2012
:Copyright: All rights reserved under the terms of the ISC license.
:Status:    Have fun.

.. _`perl(1)`: http://www.perl.org

SymObj.pm provides an easy way to create and construct symbol-tables
and objects.  With a simple hash one defines class-fields an object
should have.  A generic constructor will then create the object and
all of its superclasses, checking and filtering arguments along the
way, which makes it pretty useful in times when the interface is
unstable.  The generated accessor subs which are created for arrays
and hashes implement a *feed in and forget* approach, since they can
handle all kinds of arguments (or try it); this is also true for the
constructor.

SymObj.pm works for Multiple-Inheritance as good as `perl(1)`_ allows.
(That is to say that only one straight object tree can be used, further
trees of ``@ISA`` need to be joined into the ``$self`` hash and thus
loose *their* ``$self`` along the way, of course.)  It should integrate
neatlessly into SMP in respect to objects; package "static-data" however
is not protected.

The S-SymObj project is located at
https://sourceforge.net/projects/ssymobj; since that is a SourceForge
Beta project page, http://sdaoden.users.sourceforge.net/code.html is
maybe more interesting.  S-SymObj is developed using a git(1) repository,
which is located at git.code.sf.net/p/ssymobj/code.

WARNING
-------

S-SymObj was incompatibly rewritten with the aim of improving the use,
more features and more speed after tag v0.5.2, which has been applied
to draw this border of incompatibility!  If you knew S-SymObj before,
please reread the documentation!  And please don't expect that the
interface is really stable before the v0.6.0 release is tagged.
Thank you!

Installation
------------

SymObj.pm is a Perl module and therefore needs to be in ``@INC`` if
scripts should be able to find it easily.  This can be accomplished
by either copying SymObj.pm to one of the paths shown by ``$ perl -V``,
or by specifying a path via the ``-I`` command line option or by
placing a path in the ``PERL5LIB`` environment variable.  The last
solution is maybe the easiest and most flexible one.

Usage
-----

Please use the pod2XY family of programs for the complete and
up-to-date documentation on SymObj.pm, e.g., ::

    pod2text SymObj.pm

The (stripped down) example from the documentation as of 2012-08-24: ::

   BEGIN {
      require 'SymObj.pm';       
      $SymObj::Debug = 2; # Default: 1
   }

   ## "Feed-in and forget" ##

   {package X_Super;
      BEGIN {
         SymObj::sym_create(SymObj::NONE, { # (NONE is 0..)
               _name => '',
               _array => [qw(av1 av2)],
               _hash => {hk1 => 'hv1', hk2 => 'hv2'}
            });
      }
   }

   {package SomePack;
      our (@ISA);
      BEGIN {
         @ISA = ('X_Super');
         SymObj::sym_create(0, {}); # <- adds no fields on its own
      }
   }

   my $sp = SomePack->new(name => 'SymObj is easy', 'unknown' => 'arg');

   # Other possible ctor arguments to init ->array() and ->hash()
   # array => '1' # (Need to push the rest later on)
   # array => ['1', '2', '3', '4']
   # array => [qw(1 2 3 4)]
   # array => {1 => '2', 3 => '4'}
   # hash => [qw(i you we all)]
   # hash => {i => 'you', we => 'all'}

   # The accessor subs also try to swallow everything.
   # They return references, except for scalars (always) and in wantarray
   # context, in which case you get a copy
   my $v = $sp->name('SymObj is really nice to use');
   print "name is <$v>\n";

   my $vr;
   $vr = $sp->array(   '1_1'); $sp->array('2_1');
   $vr = $sp->array(qw( 1_2                2_2));
   $vr = $sp->array([qw(1_3                2_3)]);
   $vr = $sp->array(   '1_4' =>           '2_4');
   my @arrcopy = $sp->array(); # wantarray context gives copy instead

   $vr = $sp->hash(    i_1 => 'yo1',  we_1 => 'al1');
   $vr = $sp->hash(   'i_2',  'yo2', 'we_2',  'al2');
   $vr = $sp->hash(qw( i_3    yo3     we_3     al3));
   $vr = $sp->hash([qw(i_4    yo4     we_4     al4)]);
   $vr = $sp->hash({   i_5 => 'yo5',  we_5 => 'al5'});
   my %hashcopy = $sp->hash(); # wantarray context gives copy instead

   ## No-access/readonly accessors; "user constructors" ##

   {package FC1;
      BEGIN {
         SymObj::sym_create(0, { '?_n' => 'FC1', '!_v' => '1' },
            sub {
               my ($self, $pkg) = @_;
               print ".. FC1::{__ctor}(): (", ${$self->__n}, ")\n";
            });
      }
   }
   {package FC2;
      our (@ISA);
      BEGIN {
         @ISA = ('FC1');
         SymObj::sym_create(0, { '?_n' => 'FC2', '!_v' => '2' });
      }
      sub __ctor {
         my ($self, $pkg) = @_;
         print ".. FC2::__ctor(): (", ${$self->__n}, ")\n";
      }
   }

   my $i = FC2->new;
   die "FC2, 1" if $i->v ne '2';
   $i->v('it is readonly..');
   $i->n('no accessor for this at all..');
   FC2::n('Class static data, updated (but do not do that)');
   $i = FC2->new(v=>3);
   die "FC2, 1" if $i->v ne '3';

.. vim:set fenc=utf-8 filetype=rst syntax=rst ts=8 sts=3 sw=3 et tw=75:
