S-SymObj
========

Copyright (c) 2010 - 2011 Steffen Daode Nurpmeso <sdaoden@gmail.com>.
All rights reserved.
See the file SymObj.pm for license information.
Have fun.

SymObj.pm provides an easy way to create and construct symbol-tables and
objects.  With a simple hash one defines class-fields an object should
have.  A generic constructor will then create the object and all of its
superclasses, checking and filtering arguments along the way, which
makes it pretty useful in times when the interface is unstable.  The
generated accessor subs which are created for arrays and hashes
implement a *feed in and forget* approach, since they can handle all
kinds of arguments (or try it); this is also true for the constructor.

SymObj.pm works for Multiple-Inheritance as good as perl(1) allows.
(That is to say that only one straight object tree can used,
further trees of @ISA need to be joined in, say.)
It should integrate neatlessly into SMP in respect to objects;
package "static-data" however is not protected.

S-SymObj is developed using a git(1) repository, which is located at
https://github.com/sdaoden/s-symobj.
To download the latest version as a tarball, use
https://github.com/sdaoden/s-symobj/tarball/master.


Installation
------------

SymObj.pm is a Perl module.  It should be in @INC.
To start off, simply place it in the directory in which the perl(1)
script which shall use it resides.


Usage
-----

Please use the pod2XY family of programs for the complete and
up-to-date documentation on SymObj.pm, e.g.

    pod2text SymObj.pm

The example from the documentation as of 2011-10-21:

    BEGIN { require 'SymObj.pm'; }

    {package X_Super;
        my %Fields;
        BEGIN {
            %Fields = (_name => '', _array => [], _hash => {} );
            SymObj::sym_create(__PACKAGE__, \%Fields);
        }

        sub new { SymObj::obj_ctor(__PACKAGE__, shift, \%Fields, \@_); }
    }

    {package SomePack;
        our (@ISA);
        BEGIN {
            @ISA = ('X_Super');
            SymObj::sym_create(__PACKAGE__, {}); # <- adds no fields on its own
        }

        sub new { SymObj::obj_ctor(__PACKAGE__, shift, {}, \@_); } # <- ..
    }

    my $sp = SomePack->new(name => 'SymObj is easy', 'unknown' => 'arg');

    # Other possible ctor arguments to init ->array() and ->hash()
    # array => '1' # (Need to push the rest later on)
    # array => ['1', '2', '3', '4']
    # array => [qw(1 2 3 4)]
    # array => {1 => '2', 3 => '4'}
    # hash => [qw(i you we all)]
    # hash => {i => 'you', we => 'all'}

    # The accessor subs also try to swallow everything.
    # They return references, except for scalars (always) and in wantarray
    # context, in which case you get a copy
    my $v = $sp->name('SymObj is really nice to use');
    print "name is <$v>\n";

    my $vr;
    $vr = $sp->array(   '1_1'); $sp->array('2_1');
    $vr = $sp->array(qw( 1_2                2_2));
    $vr = $sp->array([qw(1_3                2_3)]);
    $vr = $sp->array(   '1_4' =>           '2_4');
    my @arrcopy = $sp->array(); # wantarray context gives copy instead

    $vr = $sp->hash(    i_1 => 'you',  we_1 => 'all');
    $vr = $sp->hash(   'i_2',  'you', 'we_2',  'all');
    $vr = $sp->hash(qw( i_3     you    we_3     all));
    $vr = $sp->hash([qw(i_4     you    we_4     all)]);
    $vr = $sp->hash({   i_5 => 'you',  we_5 => 'all'});
    my %hashcopy = $sp->hash(); # wantarray context gives copy instead

    SymObj::obj_dump($sp);


Note on revision control
------------------------

2011 is a special year for me, also in respect to RC.  For many years
i've used a mixed cvs(1)/svn(1) RC approach at home and at work.
But this will become impossible in 2011, and a distributed approach
with the possibility to progress locally, and thus easy merge support
etc., will be necessary.

I first tried git(1), but i've failed resoundingly.  I use version
control daily, but i don't want to think about it.  Well, git(1) has
a learning curve.  I've switched to hg(1) (Mercurial) and could use it
immediately.  At work git(1) has been chosen, i tracked dulwich and
hg-git.  But hg(1) uses Python and thus requires resources.  And there
are killer features of git(1): add -i, rebase -i, and almost anything
else with the plumbing.  It's even possible to *edit* patch hunks!

(And, as a side note: the Python repository started off with about 260
MB in march 2011, it was about 400 MB in mid-of-july.  Maybe something
like 'git gc --aggressive' will be implemented in the future though..)
So i decided to switch over to git(1) *everywhere*, even if it will
require time to learn about it in detail.

For SymObj.pm this means that there is an old public repository on
BitBucket (https://bitbucket.org/sdaoden/symobj).  This will be
supported as long as BitBucket doesn't throw away the repo!  That repo
will effectively reflect the git(1) "master" branch.  (Luckily hg(1)
supports patch series produced by "git format-patch --no-stat".)
And then there is the git(1) repo mentioned above.

P.S. (2011-09-22): i temporarily had the opinion that using
"Signed-off-by:" lines are a good thing to have.
I apologize.
