S-SymObj
========

:Author:    Steffen "Daode" Nurpmeso
:Contact:   sdaoden@users.sf.net
:Date:      2010 - 2012
:Copyright: All rights reserved under the terms of the ISC license.
:Status:    Have fun.

.. _`perl(1)`: http://www.perl.org

SymObj.pm provides an easy way to create and construct symbol-tables
and objects.  With a simple hash one defines class-fields an object
should have.  A generic constructor will then create the object and
all of its superclasses, checking and filtering arguments along the
way, which makes it pretty useful in times when the interface is
unstable.  The generated accessor subs which are created for arrays
and hashes implement a *feed in and forget* approach, since they can
handle all kinds of arguments (or try it); this is also true for the
constructor.

SymObj.pm works for Multiple-Inheritance as good as `perl(1)`_ allows.
(That is to say that only one straight object tree can be used, further
trees of ``@ISA`` need to be joined into the ``$self`` hash and thus
loose *their* ``$self`` along the way, of course.)  It should integrate
neatlessly into SMP in respect to objects; package "static-data" however
is not protected.

The S-SymObj project is located at
https://sourceforge.net/projects/ssymobj; since that is a SourceForge
Beta project page, http://sdaoden.users.sourceforge.net/code.html is
maybe more interesting.  S-SymObj is developed using a git(1) repository,
which is located at git.code.sf.net/p/ssymobj/code.

WARNING
-------

S-SymObj entered a stage of *incompatible* interface changes on
2012-07-24, starting with tag v0.6.0a.  Don't expect that the interface
to be stable before the v0.6.0 release is tagged!
If you knew S-SymObj before, please reread the documentation.
It has more features, is much easier to use and, optionally, all that
even faster than before.
Thank you!

Installation
------------

SymObj.pm is a Perl module and therefore needs to be in ``@INC`` if
scripts should be able to find it easily.  This can be accomplished
by either copying SymObj.pm to one of the paths shown by ``$ perl -V``,
or by specifying a path via the ``-I`` command line option, or by
placing a path in the ``PERL5LIB`` environment variable.  The last
solution is maybe the easiest one.

Usage
-----

Please use the pod2XY family of programs for the complete and
up-to-date documentation on SymObj.pm, e.g., ::

    pod2text SymObj.pm

The example from the documentation as of 2012-08-21: ::

   BEGIN {
      require 'SymObj.pm';       
      ($SymObj::Debug, $SymObj::Verbose, $SymObj::NoFastCTors) = (1, 0, 0);
   }

   ## "Feed-in and forget" ##

   {package X_Super;
      BEGIN {
         SymObj::sym_create(__PACKAGE__, {
               _name => '',
               _array => [qw(av1 av2)],
               _hash => {hk1 => 'hv1', hk2 => 'hv2'}
            });
      }
      sub new { SymObj::obj_ctor(__PACKAGE__, shift, \@_); }
   }

   {package SomePack;
      our (@ISA);
      BEGIN {
         @ISA = ('X_Super');
         SymObj::sym_create(__PACKAGE__, {}); # <- adds no fields on its own
      }
      sub new { SymObj::obj_ctor(__PACKAGE__, shift, \@_); }
   }

   my $sp = SomePack->new(name => 'SymObj is easy', 'unknown' => 'arg');

   # Other possible ctor arguments to init ->array() and ->hash()
   # array => '1' # (Need to push the rest later on)
   # array => ['1', '2', '3', '4']
   # array => [qw(1 2 3 4)]
   # array => {1 => '2', 3 => '4'}
   # hash => [qw(i you we all)]
   # hash => {i => 'you', we => 'all'}

   # The accessor subs also try to swallow everything.
   # They return references, except for scalars (always) and in wantarray
   # context, in which case you get a copy
   my $v = $sp->name('SymObj is really nice to use');
   print "name is <$v>\n";

   my $vr;
   $vr = $sp->array(   '1_1'); $sp->array('2_1');
   $vr = $sp->array(qw( 1_2                2_2));
   $vr = $sp->array([qw(1_3                2_3)]);
   $vr = $sp->array(   '1_4' =>           '2_4');
   my @arrcopy = $sp->array(); # wantarray context gives copy instead

   $vr = $sp->hash(    i_1 => 'you',  we_1 => 'all');
   $vr = $sp->hash(   'i_2',  'you', 'we_2',  'all');
   $vr = $sp->hash(qw( i_3    you     we_3     all));
   $vr = $sp->hash([qw(i_4    you     we_4     all)]);
   $vr = $sp->hash({   i_5 => 'you',  we_5 => 'all'});
   my %hashcopy = $sp->hash(); # wantarray context gives copy instead

   SymObj::obj_dump($sp);

   ## Adjust the per-class template (but don't do that) ##

   undef %{X_Super::hash()};
   X_Super::hash(newhk1=>'newhv1', newhk2=>'newhv2');
   $sp = SomePack->new(name => 'SymObj is really easy');
   SymObj::obj_dump($sp);

   ## "Fast-constructor" path, no/readonly accessors ##

   {package FC1;
      BEGIN {
         SymObj::sym_create(__PACKAGE__, { '?_n' => 'FC1', '!_v' => '1' },
            sub {
               my $self = shift;
               print ".. FC1::fast-ctor (", $self->{_n}, ")\n";
            });
      }
      sub new { SymObj::obj_ctor_fast(__PACKAGE__, shift, \@_); }
   }
   {package FC2;
      our (@ISA);
      BEGIN {
         @ISA = ('FC1');
         SymObj::sym_create(__PACKAGE__, { '?_n' => 'FC2', '!_v' => '2' },
            sub {
               my $self = shift;
               print ".. FC2::fast-ctor (", $self->{_n}, ")\n";
            });
      }
      sub new { SymObj::obj_ctor_fast(__PACKAGE__, shift, \@_); }
   }

   my $i = FC2->new;
   print "i->v = ", $i->v(), "\n";
   $i->v('it is readonly..');
   $i = FC2->new(v=>3);
   print "i->v = ", $i->v(), "\n";
   #$i->n('no accessor for this at all..');

.. vim:set fenc=utf-8 filetype=rst syntax=rst ts=8 sts=3 sw=3 et tw=75:
